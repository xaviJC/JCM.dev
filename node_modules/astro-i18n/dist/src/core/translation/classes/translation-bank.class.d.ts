import type { Formatters, LoadDirectives, SerializedTranslationMap, TranslationMap, TranslationProperties, TranslationVariables } from "../../../core/translation/types";
import type { ConfigTranslationLoadingRules, ConfigTranslations } from "../../../core/config/types";
import type Config from "../../../core/config/classes/config.class";
declare class TranslationBank {
    #private;
    constructor(translations?: TranslationMap, loadDirectives?: LoadDirectives);
    /**
     * Create a TranslationBank from a config's translations.
     */
    static fromConfig({ translations, translationLoadingRules }: Config): TranslationBank;
    /**
     * Get the appropriate translation for the given key, route, locale and
     * properties.
     * If no translation is found the key will be returned.
     */
    get(key: string, page: string, locale: string, fallbackLocale?: string, properties?: TranslationProperties, formatters?: Formatters, ignorePageIsolation?: boolean): string;
    getRouteGroups(): string[];
    getParamRouteGroups(): string[];
    /**
     * For every translation of the given locale, returns all the interpolation
     * and variant variables.
     */
    getLocaleTranslationVariables(locale: string): Record<string, TranslationVariables>;
    addTranslations(translations: ConfigTranslations): this;
    addTranslationLoadingRules(translationLoadingRules: ConfigTranslationLoadingRules): this;
    clear(): void;
    toClientSideObject(route: string): SerializedTranslationMap;
    toObject(): {
        loadDirectives: LoadDirectives;
        translations: TranslationMap;
    };
    toString(): string;
}
export default TranslationBank;
